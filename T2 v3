;; ------------------------------------------------------------
;; Regras:
;; - Cada celula branca deve receber um numero de 1 a N (N = qtd de celulas brancas por linha/coluna)
;; - Nenhum numero pode se repetir na mesma linha ou coluna
;; - Cada celula preta contem a soma dos valores nas 8 celulas brancas adjacentes
;; ------------------------------------------------------------

(defstruct cell
  type   ;; :white ou :black
  value) ;; valor da celula (nil para brancas ainda vazias)

;; Tabuleiro inicial (0 = celula branca)
(defparameter *puzzle*
  '((0 11 9 0 14 0 0 0)
    (0 0 0 17 0 0 18 12)
    (0 17 18 0 0 14 0 0)
    (12 0 16 0 16 0 0 0)
    (0 0 0 15 0 16 0 9)
    (12 0 0 0 10 0 18 0)
    (0 20 0 20 0 16 0 0)
    (6 0 0 0 0 0 11 9)))

;; Dimensoes da matriz
(defparameter *rows* (length *puzzle*))
(defparameter *cols* (length (first *puzzle*)))

;; Construcao da grade de celulas
(defun make-grid (matrix)
  (loop for r from 0 below *rows*
        collect
        (loop for c from 0 below *cols*
              collect
              (let ((val (nth c (nth r matrix))))
                (if (= val 0)
                    (make-cell :type :white :value nil)
                    (make-cell :type :black :value val))))))

(defparameter *initial-grid* (make-grid *puzzle*))

;; ------------------------------------------------------------
;; Funcoes utilitarias
;; ------------------------------------------------------------

(defun get-cell (grid row col)
  ;; Retorna a celula (row,col) ou NIL se estiver fora da grade
  (and (>= row 0) (< row *rows*)
       (>= col 0) (< col *cols*)
       (nth col (nth row grid))))

(defun set-cell (grid row col new-cell)
  ;; Retorna nova grade com a celula (row,col) atualizada
  (let ((new-row (copy-list (nth row grid))))
    (setf (nth col new-row) new-cell)
    (append (subseq grid 0 row)
            (list new-row)
            (subseq grid (1+ row)))))

(defun is-white? (cell) (eq (cell-type cell) :white))
(defun is-black? (cell) (eq (cell-type cell) :black))

;; Retorna as celulas brancas de uma linha ou coluna
(defun row-white-cells (grid row)
  (remove-if-not #'is-white? (nth row grid)))

(defun col-white-cells (grid col)
  (remove-if-not #'is-white?
                 (mapcar (lambda (row) (nth col row)) grid)))

;; ------------------------------------------------------------
;; Validacoes do puzzle
;; ------------------------------------------------------------

(defun neighbors-8 (row col)
  ;; Retorna coordenadas das 8 celulas vizinhas
  (remove-if-not
   (lambda (pos)
     (let ((r (first pos)) (c (second pos)))
       (and (>= r 0) (< r *rows*) (>= c 0) (< c *cols*))))
   (list
    (list (1- row) (1- col)) (list (1- row) col) (list (1- row) (1+ col))
    (list row (1- col))       (list row (1+ col))
    (list (1+ row) (1- col)) (list (1+ row) col) (list (1+ row) (1+ col)))))


(defun check-row-col (grid row col val)
  ;; Garante que o valor nao se repete na linha nem coluna
  (and (not (member val (mapcar #'cell-value (row-white-cells grid row))))
       (not (member val (mapcar #'cell-value (col-white-cells grid col))))))

(defun check-black-sum (grid row col)
  ;; Verifica se uma celula preta ja tem a soma correta
  (let ((cell (get-cell grid row col)))
    (if (is-black? cell)
        (let* ((neighbors (neighbors-8 row col))
               (white-neigh (remove-if-not
                             (lambda (pos)
                               (is-white? (get-cell grid (first pos) (second pos))))
                             neighbors))
               (values (mapcar
                        (lambda (pos)
                          (cell-value (get-cell grid (first pos) (second pos))))
                        white-neigh)))
          (if (member nil values)
              t  ;; ainda incompleto, mas valido
              (= (reduce #'+ values) (cell-value cell))))
        t)))

(defun check-black-sum-partial (grid row col)
  ;; Verifica se a soma ainda pode ser alcancada (para poda)
  (let ((cell (get-cell grid row col)))
    (if (is-black? cell)
        (let* ((neighbors (neighbors-8 row col))
               (white-neigh (remove-if-not
                             (lambda (pos)
                               (is-white? (get-cell grid (first pos) (second pos))))
                             neighbors))
               (values (mapcar
                        (lambda (pos)
                          (cell-value (get-cell grid (first pos) (second pos))))
                        white-neigh))
               (filled (remove nil values))
               (sum-filled (reduce #'+ filled :initial-value 0))
               (empty-count (- (length white-neigh) (length filled)))
               (max-val (max (length (row-white-cells grid row))
                             (length (col-white-cells grid col))))
               (min-val 1)
               (max-possible-sum (+ sum-filled (* empty-count max-val)))
               (min-possible-sum (+ sum-filled (* empty-count min-val))))
          (and (<= sum-filled (cell-value cell))
               (>= max-possible-sum (cell-value cell))
               (<= min-possible-sum (cell-value cell))))
        t)))

(defun all-black-ok? (grid)
  ;; Verifica se todas as celulas pretas estao corretas
  (loop for r from 0 below *rows*
        always (loop for c from 0 below *cols*
                     always (check-black-sum grid r c))))

;; ------------------------------------------------------------
;; Backtracking com poda
;; ------------------------------------------------------------

(defun empty-positions (grid)
  ;; Lista todas as posicoes ainda vazias
  (loop for r from 0 below *rows*
        append
        (loop for c from 0 below *cols*
              when (and (is-white? (get-cell grid r c))
                        (null (cell-value (get-cell grid r c))))
              collect (list r c))))

(defun possible-values (grid row col)
  ;; Retorna os valores possiveis para uma posicao
  (let ((n (max (length (row-white-cells grid row))
                (length (col-white-cells grid col)))))
    (remove-if-not (lambda (v) (check-row-col grid row col v))
                   (loop for i from 1 to n collect i))))

(defun choose-mrv (grid empties)
  ;; Escolhe a celula com menos opcoes (heuristica MRV)
  (let ((min-size most-positive-fixnum)
        (best nil))
    (dolist (pos empties)
      (let* ((vals (possible-values grid (first pos) (second pos)))
             (size (length vals)))
        (when (< size min-size)
          (setf min-size size
                best (cons pos vals)))))
    best))

(defun check-affected-blacks (grid row col)
  ;; Checa se as celulas pretas vizinhas ainda sao validas
  (let ((black-neighs (remove-if-not
                       (lambda (pos)
                         (is-black? (get-cell grid (first pos) (second pos))))
                       (neighbors-8 row col))))
    (every (lambda (pos)
             (check-black-sum-partial grid (first pos) (second pos)))
           black-neighs)))

(defun solve (grid)
  ;; Funcao recursiva principal
  (let ((empties (empty-positions grid)))
    (if (null empties)
        (if (all-black-ok? grid) grid nil)
        (let* ((choice (choose-mrv grid empties))
               (pos (car choice))
               (vals (cdr choice))
               (r (first pos))
               (c (second pos)))
          (loop for val in vals
                thereis
                (let ((new-grid (set-cell grid r c
                                          (make-cell :type :white :value val))))
                  (when (check-affected-blacks new-grid r c)
                    (solve new-grid))))))))

;; ------------------------------------------------------------
;; Impressao e execucao
;; ------------------------------------------------------------

(defun print-grid (grid)
  ;; Mostra o tabuleiro no terminal
  (dolist (row grid)
    (dolist (cell row)
      (format t "~a "
              (cond
                ((is-white? cell) (or (cell-value cell) ?.))
                ((is-black? cell) (cell-value cell)))))
    (terpri)))

;; Programa principal
(let ((solution (solve *initial-grid*)))
  (if solution
      (progn
        (format t "Solucao encontrada:~%")
        (print-grid solution))
      (format t "Sem solucao.")))
