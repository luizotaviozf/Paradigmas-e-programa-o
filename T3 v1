:- use_module(library(clpfd)).
:- use_module(library(lists)).

% -------------------------
% Conta prédios visíveis (versão não CLPFD)
% -------------------------
count_visible_plain(Row, Count) :-
    count_visible_plain(Row, 0, 0, Count).

count_visible_plain([], _Max, Count, Count).
count_visible_plain([0|T], Max, C0, C) :-    % parque, ignora
    count_visible_plain(T, Max, C0, C).
count_visible_plain([H|T], Max, C0, C) :-
    H > Max, !,
    C1 is C0 + 1,
    count_visible_plain(T, H, C1, C).
count_visible_plain([_H|T], Max, C0, C) :-
    count_visible_plain(T, Max, C0, C).

visible_check_left(Row, Clue) :-
    count_visible_plain(Row, Count),
    Count =:= Clue.

visible_check_right(Row, Clue) :-
    reverse(Row, Rev),
    count_visible_plain(Rev, Count),
    Count =:= Clue.

% -------------------------
% Cada linha/coluna deve conter exatamente uma vez 1..MAX e exatamente um 0
% -------------------------
row_valid(Row, Max) :-
    length(Row, L),
    L is Max + 1,                % tamanho: MAX prédios + 1 parque
    findall(X, between(1, Max, X), Heights),
    permutation([0|Heights], Row).

% -------------------------
% Resolve o puzzle
% -------------------------
solve(Grid) :-
    N = 6,
    Max is N - 1,  % 5 prédios + 1 parque
    length(Grid, N),
    maplist(same_length(Grid), Grid),

    % Cada linha é permutação de [0,1,2,3,4,5]
    maplist(row_valid, Grid, [Max,Max,Max,Max,Max,Max]),

    % Colunas distintas (cada número 1..5 e 0 ocorre uma vez)
    transpose(Grid, Columns),
    maplist(all_distinct, Columns),

    % Pistas
    Left   = [4,3,3,3,1,2],
    Right  = [2,2,2,1,2,2],
    Top    = [3,3,1,2,1,3],
    Bottom = [2,1,4,3,5,3],

    % Flatten para labeling (gera todas permutações)
    append(Grid, Vars),
    Vars ins 0..Max,
    labeling([], Vars),

    % Checa pistas
    maplist(visible_check_left, Grid, Left),
    maplist(visible_check_right, Grid, Right),
    transpose(Grid, Cols),
    maplist(visible_check_left, Cols, Top),
    maplist(visible_check_right, Cols, Bottom).

% -------------------------
% Impressão
% -------------------------
print_cell(0) :- write('c').
print_cell(X) :- write(X).

print_cells([]).
print_cells([Last]) :- !, print_cell(Last).
print_cells([H|T]) :-
    print_cell(H),
    write(','),
    print_cells(T).

print_row(Row) :-
    write('['),
    print_cells(Row),
    writeln(']').

print_grid([]).
print_grid([R|Rs]) :-
    print_row(R),
    print_grid(Rs).

% -------------------------
% Ponto de entrada automático
% -------------------------
:- initialization(main).

main :-
    ( solve(Grid) ->
        writeln('--- Solução encontrada ---'),
        print_grid(Grid)
    ; writeln('Nenhuma solução encontrada.')
    ),
    halt.
